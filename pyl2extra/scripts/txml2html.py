"""
Code for printing values as they are being computed by Theano.

This mode is inspired by nan_guard module in pylearn2.devtools.
"""

__authors__ = "Nicu Tofan"
__copyright__ = "Copyright 2015, Nicu Tofan"
__credits__ = ["Nicu Tofan"]
__license__ = "3-clause BSD"
__maintainer__ = "Nicu Tofan"
__email__ = "nicu.tofan@gmail.com"

import Image
import json
import logging
import os
import shutil
from xml.dom.minidom import parse

try:
    import pydot as pd
    if pd.find_graphviz():
        pydot_imported = True
    else:
        pydot_imported = False
except ImportError:
    pydot_imported = False

from pyl2extra.utils.script import setup_logging, make_argument_parser


class Txml2Html(object):
    """
    Generate html page from xml generated by XmlValMode.

    Parameters
    ----------
    xml_file : str
        Path to input file. It is expected that this file was generated by
        pyl2extra.devtools.printvalmode.XmlValMode.
    output : str
        Path to and base name for the output. ``/a/b/c/d`' will create
        output in ``/a/b/c`` directory; the files to be generated are
        ``d.html``, ``d.png``, ``d.cmapx``.
    Notes
    -----
    The constructor will attempt to create parent directory but not the entire
    path.
    """
    def __init__(self, xml_file, output,
                 html_prefix=None, html_suffix=None,
                 graphid=None):

        self.html_prefix = html_prefix
        self.html_suffix = html_suffix
        self.graphid = graphid

        output = os.path.abspath(output)
        self.xml_file = xml_file
        self.output = output

        logging.debug("input: %s", xml_file)

        self.out_path = os.path.split(output)[0]
        self.out_html = '%s.html' % output
        self.out_png = '%s.png' % output
        self.out_dot = '%s.dot' % output
        self.out_js = '%s.js' % output
        self.out_cmapx = '%s.cmapx' % output
        logging.debug("output: %s", self.out_html)
        logging.debug("output: %s", self.out_png)
        logging.debug("output: %s", self.out_cmapx)

        if not os.path.isdir(self.out_path):
            os.mkdir(self.out_path)

        self.graph = None
        self.nodes = {}
        self.edges = []

        self.reverse_nodes = []
        self.reverse_edges = []
        dom = parse(self.xml_file)
        self.domnodes = dom.getElementsByTagName('node')

        #: a view of the whole dataset; see `process()`
        self.view = None

        super(Txml2Html, self).__init__()

    def gen_full(self):
        """
        Generate the graph for the whole computation.

        This is similar to pydotprint from theano.ptinting in that it shows
        edges between variables and ops, with each variable and each op
        printed a exactly one time.
        """
        self.graphid = 'gfull' if self.graphid is None else self.graphid
        self.graph = pd.Dot(graph_type='digraph',
                            rankdir='TB',
                            graph_name=self.graphid)

        for i, node in enumerate(self.domnodes):
            hval = int(node.getAttribute('hash'))
            nval = '(%d) %s' % (i, node.getAttribute('name'))

            existing, hval = self._add_op(hval, node, True, nval)
            if existing:
                # not the first time we see you
                continue

            inputs = node.getElementsByTagName('inputs')[0]
            for lst in inputs.getElementsByTagName('list'):
                hvar = int(lst.getAttribute('hash'))
                nvar = lst.getAttribute('variable')
                existing, hvar = self._add_var(hvar, lst, True, nvar)
                existing, edge = self._add_edge(hvar, hval)
                if not existing:
                    self._create_edge(edge)

            outputs = node.getElementsByTagName('outputs')[0]
            for lst in outputs.getElementsByTagName('list'):
                hvar = int(lst.getAttribute('hash'))
                nvar = lst.getAttribute('variable')
                existing, hvar = self._add_var(hvar, lst, True, nvar)
                existing, edge = self._add_edge(hval, hvar)
                if not existing:
                    self._create_edge(edge)

        self._finalize()

    def gen_inputs(self):
        """
        Generate the graph for the opperations and the inputs to them.

        The graph has variables on the left side and operations on the
        right side. A variable may be shown multiple times but opperations
        are shown only once, in the order of execution, from top to bottom.
        """
        self.graphid = 'ginputs' if self.graphid is None else self.graphid
        self.graph = pd.Dot(graph_type='digraph',
                            rankdir='LR',
                            graph_name=self.graphid)
        for i, node in enumerate(self.domnodes):
            hval = int(node.getAttribute('hash'))
            nval = '(%d) %s' % (i, node.getAttribute('name'))

            existing, hval = self._add_op(hval, node, True, nval)
            if existing:
                # not the first time we see you
                continue

            inputs = node.getElementsByTagName('inputs')[0]
            for lst in inputs.getElementsByTagName('list'):
                hvar = int(lst.getAttribute('hash'))
                nvar = lst.getAttribute('variable')
                hvar = 'var%sx%d' % (hval, hvar)
                existing, hvar = self._add_var(hvar, lst, True, nvar)
                existing, edge = self._add_edge(hvar, hval)
                if not existing:
                    self._create_edge(edge)

        self._finalize()

    def gen_outputs(self):
        """
        Generate the graph for the opperations and the outputs to them.

        The graph has variables on the right side and operations on the
        left side. A variable may be shown multiple times but opperations
        are shown only once, in the order of execution, from top to bottom.
        """
        self.graphid = 'goutputs' if self.graphid is None else self.graphid
        self.graph = pd.Dot(graph_type='digraph',
                            rankdir='LR',
                            graph_name=self.graphid)
        for i, node in enumerate(self.domnodes):
            hval = int(node.getAttribute('hash'))
            nval = '(%d) %s' % (i, node.getAttribute('name'))

            existing, hval = self._add_op(hval, node, True, nval)
            if existing:
                # not the first time we see you
                continue

            outputs = node.getElementsByTagName('outputs')[0]
            for lst in outputs.getElementsByTagName('list'):
                hvar = int(lst.getAttribute('hash'))
                nvar = lst.getAttribute('variable')
                hvar = 'var%sx%d' % (hval, hvar)
                existing, hvar = self._add_var(hvar, lst, True, nvar)
                existing, edge = self._add_edge(hval, hvar)
                if not existing:
                    self._create_edge(edge)
        self._finalize()

    def gen_inouts(self):
        """
        Generate the graph for the opperations and the outputs to them.

        The graph has variables on the right side and operations on the
        left side. A variable may be shown multiple times but opperations
        are shown only once, in the order of execution, from top to bottom.
        """
        self.graphid = 'ginouts' if self.graphid is None else self.graphid
        self.graph = pd.Dot(graph_type='digraph',
                            rankdir='LR',
                            graph_name=self.graphid)
        for i, node in enumerate(self.domnodes):
            hval = int(node.getAttribute('hash'))
            nval = '(%d) %s' % (i, node.getAttribute('name'))

            existing, hval = self._add_op(hval, node, True, nval)
            if existing:
                # not the first time we see you
                continue

            inputs = node.getElementsByTagName('inputs')[0]
            for lst in inputs.getElementsByTagName('list'):
                hvar = int(lst.getAttribute('hash'))
                nvar = lst.getAttribute('variable')
                hvar = 'input%sx%d' % (hval, hvar)
                existing, hvar = self._add_var(hvar, lst, True, nvar)
                existing, edge = self._add_edge(hvar, hval)
                if not existing:
                    self._create_edge(edge)

            outputs = node.getElementsByTagName('outputs')[0]
            for lst in outputs.getElementsByTagName('list'):
                hvar = int(lst.getAttribute('hash'))
                nvar = lst.getAttribute('variable')
                hvar = 'output%sx%d' % (hval, hvar)
                existing, hvar = self._add_var(hvar, lst, True, nvar)
                existing, edge = self._add_edge(hval, hvar)
                if not existing:
                    self._create_edge(edge)

        self._finalize()

    def parse(self):
        """
        Constructs a view of the data from xml file.

        The structure is organized as follows:
        - at top level it is a dictionary mapping hashes to Op nodes;
        - each Op node has a name, op name, number of inputs and outputs
          and a list of epochs;
        - each epoch consist of a dictionary with two keys: input and output;
          these are on their turn list of variables;
        - variables are dictionaries with a name, hash, data type, shape
          and kind; associated data format depends on kind;
        - for integer, real and cplx types the values are used directly;
        - for vector and matrix they are lists
        - for ndarray they are dictionaries, with keys being the
          address of the matrix and the values matrices (last two dimensions)

        Example
        -------

.. code:

        {
            '12345': {
                    name: "some name",
                    op: "some op",
                    inputs: 3,
                    outputs, 1
                    epochs: [
                        {
                            input: [
                                {
                                    name: "var label"
                                    hash: "456789",
                                    dtype: "uint8",
                                    shape: [1,2,3,4,5]
                                    kind: integer, real, cplx, vector, matrix, ndarray
                                    data:
                                }
                            ],
                            output: [
                                {
                                    name: "var label"
                                    hash: "456789,
                                    dtype: "uint8",
                                    shape: [1,2,3,4,5]
                                    kind: integer, real, cplx, vector, matrix, ndarray
                                    data:
                                }
                            ]
                        }
                    ]
                }
        }

        """
        self.view = {}
        for i, node in enumerate(self.domnodes):
            hval = int(node.getAttribute('hash'))

            # get node data
            if self.view.has_key(hval):
                opnode = self.view[hval]
                epochs = opnode['epochs']
            else:
                epochs = []
                opnode = {'name': node.getAttribute('name'),
                          'op': node.getAttribute('op'),
                          'inputs': int(node.getAttribute('inputs')),
                          'outputs': int(node.getAttribute('outputs')),
                          'epochs': epochs}
                self.view[hval] = opnode

            # create a new epoch for this apparition
            inputs = []
            outputs = []
            epoc = {'input': inputs, 'output': outputs}
            epochs.append(epoc)

            def _get_text(node):
                """Get the text inside an element."""
                nodelist = node.childNodes
                result = []
                for node in nodelist:
                    if node.nodeType == node.TEXT_NODE:
                        result.append(node.data)
                return ''.join(result)

            def _get_part(node, dtype):
                """Get the text and convert it to an array of numbers."""
                txt = _get_text(node).split('|')
                if dtype.startswith('int') or dtype.startswith('uint'):
                    parts = [int(x) for x in txt]
                else:
                    parts = [float(x) for x in txt]
                return parts

            def _do_var(xmlnode, lst):
                """
                Reads a variable and  inserts it into the list.
                """
                hvar = int(xmlnode.getAttribute('hash'))
                varobj = {'name': xmlnode.getAttribute('variable'),
                          'hash': hvar}
                lst.append(varobj)

                valnodes = xmlnode.getElementsByTagName('value')
                if len(valnodes) > 0:
                    valnodes = valnodes[0]
                    val = _get_text(valnodes)
                    try:
                        val = int(val)
                        varobj['dtype'] = 'int'
                        varobj['kind'] = 'integer'
                    except ValueError:
                        val = float(val)
                        varobj['dtype'] = 'float'
                        varobj['kind'] = 'integer'
                    varobj['shape'] = []
                    varobj['data'] = val
                    return

                valnodes = xmlnode.getElementsByTagName('integer')
                if len(valnodes) > 0:
                    valnodes = valnodes[0]
                    varobj['dtype'] = valnodes.getAttribute('dtype')
                    varobj['shape'] = []
                    varobj['kind'] = 'integer'
                    varobj['data'] = int(valnodes.getAttribute('value'))
                    return

                valnodes = xmlnode.getElementsByTagName('real')
                if len(valnodes) > 0:
                    valnodes = valnodes[0]
                    varobj['dtype'] = valnodes.getAttribute('dtype')
                    varobj['shape'] = []
                    varobj['kind'] = 'real'
                    varobj['data'] = float(valnodes.getAttribute('value'))
                    return

                valnodes = xmlnode.getElementsByTagName('cplx')
                if len(valnodes) > 0:
                    valnodes = valnodes[0]
                    varobj['dtype'] = valnodes.getAttribute('dtype')
                    varobj['shape'] = []
                    varobj['kind'] = 'cplx'
                    varobj['data'] = [float(valnodes.getAttribute('r')),
                                      float(valnodes.getAttribute('i'))]
                    return

                valnodes = xmlnode.getElementsByTagName('ndarray')
                if len(valnodes) > 0:
                    valnodes = valnodes[0]
                    varobj['dtype'] = valnodes.getAttribute('dtype')
                    shape = valnodes.getAttribute('shape').split(',')
                    shape = [int(x) for x in shape]
                    varobj['shape'] = shape
                    assert len(shape) > 0

                    parts = xmlnode.getElementsByTagName('part')
                    if len(shape) == 1:
                        varobj['kind'] = 'vector'
                        assert len(parts) == 1
                        lpart = _get_part(parts[0], varobj['dtype'])
                        assert len(lpart) == shape[-1]
                        varobj['data'] = lpart

                    elif len(shape) == 2:
                        varobj['kind'] = 'matrix'
                        assert len(parts) == shape[0]
                        matrix = []
                        for partnode in parts:
                            lpart = _get_part(partnode, varobj['dtype'])
                            assert len(lpart) == shape[-1]
                            matrix.append(lpart)
                        assert len(matrix) == shape[0]
                        varobj['data'] = matrix
                    else:
                        varobj['kind'] = 'ndarray'
                        crt_idx = 0
                        matrix = []
                        ndarray = {}
                        ndaddress = None
                        for partnode in parts:
                            address = partnode.getAttribute('address')
                            address = address.split(',')
                            if not ndaddress:
                                ndaddress = address[:-1]
                            assert len(address) == len(shape) - 1
                            lpart = _get_part(partnode, varobj['dtype'])
                            assert len(lpart) == shape[-1]

                            if address[-2] == crt_idx:
                                matrix.append(lpart)
                            else:
                                ndarray[ndaddress] = matrix
                                crt_idx = address[-2]
                                matrix = [lpart]
                        ndarray[ndaddress] = matrix
                    return


                raise ValueError('Variable %d without value;\n%s' %
                                 (hvar, _get_text(xmlnode)))

            # get input variables
            innodelist = node.getElementsByTagName('inputs')[0]
            for lst in innodelist.getElementsByTagName('list'):
                _do_var(lst, inputs)

            # get output variables
            outnodelist = node.getElementsByTagName('outputs')[0]
            for lst in outnodelist.getElementsByTagName('list'):
                _do_var(lst, outputs)

    def _add_op(self, hval, obj, create_dot=True, label=None):
        """
        Adds a node to internal map and to dot graph.

        If the hash is already present then the object is added to the list,
        otherwise a new list is created.

        Parameters
        ----------
        hval : int or str
            The unique identifier for the node.
        obj : object
            The xml element
        create_dot : bool
            If the node does not exist should we create it?
        label : str
            The label for the node. If None (default) the name is extracted
            from xml node ``obj``.

        Returns
        -------
        existing, hval : bool and str
            ``existing`` is True if the has was seen before, False if
            this is new. ``hval`` has the final identifier.
        """
        existing, hval = self._add_node(hval, obj)
        if not existing:
            if create_dot:
                if label is None:
                    label = obj.getAttribute('name')
                self.reverse_nodes.append({'name': hval,
                                           'label': label,
                                           'style': 'filled',
                                           'fillcolor': '#ffffff',
                                           'shape': 'ellipse',
                                           'URL': '#\\N'})
        return existing, hval

    def _add_var(self, hval, obj, create_dot=True, label=None):
        """
        Adds a node to internal map and to dot graph.

        If the hash is already present then the object is added to the list,
        otherwise a new list is created.

        Parameters
        ----------
        hval : int or str
            The unique identifier for the node.
        obj : object
            The xml element
        create_dot : bool
            If the node does not exist should we create it?
        label : str
            The label for the node. If None (default) the name is extracted
            from xml node ``obj``.

        Returns
        -------
        existing, hval : bool and str
            ``existing`` is True if the has was seen before, False if
            this is new. ``hval`` has the final identifier.
        """
        existing, hval = self._add_node(hval, obj)
        if not existing:
            if create_dot:
                if label is None:
                    label = obj.getAttribute('name')
                self.reverse_nodes.append({'name': hval,
                                           'label': label,
                                           'style': 'filled',
                                           'fillcolor': '#ff0000',
                                           'shape': 'box',
                                           'URL': '#\\N'})
        return existing, hval

    def _add_node(self, hval, obj):
        """
        Adds a node to internal map.

        If the hash is already present then the object is added to the list,
        otherwise a new list is created.

        Parameters
        ----------
        hval : int or str
            The unique identifier for the node.
        obj : object
            The xml element

        Returns
        -------
        existing, hval : bool and str
            ``existing`` is True if the has was seen before, False if
            this is new. ``hval`` has the final identifier.
        """
        if isinstance(hval, int):
            hval = 'n%d' % hval
        if self.nodes.has_key(hval):
            self.nodes[hval].append(obj)
            existing = True
        else:
            self.nodes[hval] = [obj]
            existing = False
        return existing, hval

    def _add_edge(self, src, dst):
        """
        Adds a node to internal map.

        If the hash is already present then the object is added to the list,
        otherwise a new list is created.

        Parameters
        ----------
        src : int or str
            The unique identifier for the source node.
        dst : int or str
            The unique identifier for the destination node.

        Returns
        -------
        existing, edge : bool and tuple
            ``existing`` tells if the edge was seen before;
            ``edge`` has the canonical form for the edge as stored in
            `self.edges`.
        """
        if isinstance(src, int):
            src = 'n%d' % src
        if isinstance(dst, int):
            dst = 'n%d' % dst
        edge = (src, dst)
        if edge in self.edges:
            existing = True
        else:
            self.edges.append(edge)
            existing = False
        return existing, edge

    def _create_edge(self, edge):
        """
        Creates a dot edge.
        """
        self.reverse_edges.append({'src': edge[0], 'dst': edge[1]})
        #        graph.add_edge(pd.Edge(src='n%d' % src,
        #                               dst='n%d' % dst,
        #                               label=lbl,
        #                               labelaligned=True,
        #                               style='',
        #                               color='black'))


    def _finalize(self):
        """
        Create output files.
        """

        if not self.view:
            self.parse()

        for ndins in reversed(self.reverse_nodes):
            nw_node = pd.Node(**ndins)
            self.graph.add_node(nw_node)
        for edgins in reversed(self.reverse_edges):
            dote = pd.Edge(**edgins)
            self.graph.add_edge(dote)

        self.graph.write(self.out_dot, prog='dot', format='dot')
        self.graph.write(self.out_png, prog='dot', format='png')
        self.graph.write(self.out_cmapx, prog='dot', format='cmapx')

        img_file = os.path.split(self.out_png)[1]
        with open(self.out_cmapx, 'rt') as fhand:
            cmapx = fhand.read()

        img = Image.open(self.out_png)
        img_w, img_h = img.size
        img = None

        if not self.html_prefix:
            self.html_prefix = """<!DOCTYPE html>
<html>
<head>
    <title>Theano graph</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="MobileOptimized" content="320" />
    <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1" />
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width">

    <!-- Bootstrap core CSS -->
    <link href="http://getbootstrap.com/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
        <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <link rel="stylesheet" href="https://ajax.googleapis.com/ajax/libs/jqueryui/1.11.4/themes/smoothness/jquery-ui.css">
    <link rel="stylesheet" href="http://cdn.datatables.net/1.10.7/css/jquery.dataTables.min.css">

   <style>
    body {
        font-family: Helvetica, Arial, sans-serif;
    }
    h1 {
        font-size: 20px;
    }
    img[usemap] {
        border: none;
        height: auto;
        max-width: 100%;
        width: auto;
    }
    .ui-dialog{font-size: 75%;}
    th, tr {
        text-align: center;
    }
    .ui-dialog-titlebar .PinDialog, .ui-dialog-titlebar .DialogPinned {
    	float: left;
        height: 20px;
        margin: 0 5px 0 -10px;
        padding: 1px;
        top: 50%;
        width: 20px;
    }
    </style>

</head>
<body>
<div class="container">

    <h1>Theano graph</h1>

    <div class="row">
        <div class="col-md-12">
"""
        if not self.html_suffix:
            self.html_suffix = """
         </div>
    </div>
</div>

<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<!--script src="jquery-1.11.3.js"></script-->
<script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.11.4/jquery-ui.min.js"></script>
<script src="http://mattstow.com/experiment/responsive-image-maps/jquery.rwdImageMaps.min.js"></script>
<script src="http://cdn.datatables.net/1.10.7/js/jquery.dataTables.min.js"></script>
<!--script src="jquery.dataTables.js"></script-->
<script src="out.js"></script>
<script src="txml2html.js"></script>

<div id="dialoglist" class="hide">
<div id="nodedialog" title="Basic dialog">
    <dl class="dl-horizontal">
        <dt>Name</dt><dd id="ndd_node_name"></dd>
        <dt>Op</dt><dd id="ndd_node_op"></dd>
        <dt>Inputs</dt><dd id="ndd_node_inp"></dd>
        <dt>Outputs</dt><dd id="ndd_node_outp"></dd>
        <dt>Epochs</dt><dd id="ndd_node_ep"></dd>
    </dl>
    <div id="ndd_form"></div>
    <div id="ndd_var_brief"></div>
    <div id="ndd_var_value">
    </div>
</div>
</div>

<script>

</script>
</body>
"""

        with open(self.out_js, 'wt') as fhand:
            fhand.write('(function() { \n  window.%s_data = ' % self.graphid)
            json.dump(self.view, fhand, indent=2, separators=(',', ': '))
            fhand.write(';\n  window.tx2h_data = window.%s_data;\n' % self.graphid)
            fhand.write('\n})();\n')

        # js file with helper routines
        srcjs = os.path.join(os.path.split(os.path.abspath(__file__))[0],
                             'trunk',
                             'txml2html.js')
        dstjs = os.path.join(os.path.split(self.output)[0], 'txml2html.js')
        shutil.copy(srcjs, dstjs)

        with open(self.out_html, 'wt') as fhand:
            fhand.write(self.html_prefix)
            fhand.write('<img src="%s" '
                        'width="%d" '
                        'height="%d" '
                        'usemap="#%s" '
                        'id="img%s" '
                        'alt="" />' % (img_file,
                                       img_w,
                                       img_h,
                                       self.graphid,
                                       self.graphid))
            fhand.write(cmapx)
            fhand.write(self.html_suffix)


def parse_args():
    """
    Add arguments specific for this script to the parser; parse arguments.
    """
    parser = make_argument_parser("Debugger for pylearn2 models.")
    parser.add_argument('--mode',
                        type=str,
                        help='How to arrange nodes in the graph.',
                        choices=['full', 'inputs', 'outputs', 'inouts'],
                        default='full')
    parser.add_argument('xml_file',
                        type=str,
                        help='The file to convert.',
                        default=None)
    parser.add_argument('output',
                        type=str,
                        help='The output path and base file name.',
                        default=None)
    return parser.parse_args()

def main():
    """
    Module entry point.
    """
    args = parse_args()

    # prepare logging
    setup_logging(args)
    logging.debug("Application starting...")

    if not pydot_imported:
        logging.error('pydot could not be imported.')
    else:
        # run based on request
        x2h = Txml2Html(args.xml_file, args.output)
        if args.mode == 'full':
            x2h.gen_full()
        elif args.mode == 'inputs':
            x2h.gen_inputs()
        elif args.mode == 'outputs':
            x2h.gen_outputs()
        elif args.mode == 'inouts':
            x2h.gen_inouts()
        else:
            logging.error('Unknown mode: %s', args.mode)
    logging.debug("Application ended")

if __name__ == '__main__':
    main()
