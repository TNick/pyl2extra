"""
Provides a drop-in replacement for theano.printing.pydotprint().

The code was initially copied from theano.printing.pydotprint() and
it was modified.
"""

import logging
import os
import random

try:
    import pydot as pd
    if pd.find_graphviz():
        pydot_imported = True
    else:
        pydot_imported = False
except ImportError:
    pydot_imported = False

import theano
from theano import gof
from theano import config
from theano.compile import Function
from theano.compile.profilemode import ProfileMode
from theano.printing import default_colorCodes


_logger = logging.getLogger("pyl2extra.printing")
VALID_ASSOC = set(['left', 'right', 'either'])


class GraphNode(object):
    """
    A node in our tree.

    We're creating a tree to mimic the structure of the graph as we build it.

    Parameters
    ----------
    name : str
        The unique name that will be used to identify this node in out
        tree and in dot graph. unique_apply_name() or unique_var_name()
        can be used to to generate this.
    obj : object
        The actual object that will be inserted.
    parent : GraphNode, optional
        Parent node or None to insert it at top level.
    """
    def __init__(self, name, obj, parent=None, index=-1):
        """
        Constructor.
        """
        super(GraphNode, self).__init__()

        self.obj = obj

        self.name = name
        self.label = None

        # currently this can be 'apply', 'input' or 'output'
        self.kind = None

        # parent and index in parent
        self.parent = parent
        self.index = index

        # TODO
        self.subtree = {}

        # a node generated by a pd.Node()
        self.dotnode = None

class PyDotPrinter(object):
    """
    Print to a file the graph of a compiled theano function's ops. Supports
    all pydot output formats, including png and svg.

    Throughout the class the distinction is made between names
    (properly formated strings to act as dot names) and labels (the string
    displayed by that node).
    """
    def __init__(self,
                 fct,
                 compact=True,
                 outfrm='png',
                 with_ids=False,
                 high_contrast=True,
                 color_codes=None,
                 max_label_size=70,
                 var_with_name_simple=False):
        """
        Constructor.
        """
        super(PyDotPrinter, self).__init__()

        self.fct = fct
        self.compact = compact
        self.outfrm = outfrm
        self.with_ids = with_ids
        self.high_contrast = high_contrast
        self.color_codes = color_codes
        self.max_label_size = max_label_size
        self.var_with_name_simple = var_with_name_simple

        if not pydot_imported:
            raise RuntimeError("Failed to import pydot. You must install pydot"
                               " for `pydotprint` to work.")
        if color_codes is None:
            self.color_codes = default_colorCodes

        if not self.color_codes.has_key('input_update'):
            self.color_codes['input_update'] = 'lightblue'
        if not self.color_codes.has_key('outputs'):
            self.color_codes['outputs'] = 'blue'
        if not self.color_codes.has_key('inputs'):
            self.color_codes['inputs'] = 'green'
        if not self.color_codes.has_key('noclients'):
            self.color_codes['noclients'] = 'grey'
        if not self.color_codes.has_key('edge'):
            self.color_codes['edge'] = 'black'
        if not self.color_codes.has_key('view'):
            self.color_codes['view'] = 'blue'
        if not self.color_codes.has_key('destroy'):
            self.color_codes['destroy'] = 'red'
        if not self.color_codes.has_key('apply'):
            if self.high_contrast:
                self.color_codes['apply'] = 'white'
            else:
                self.color_codes['apply'] = 'black'
        if not self.color_codes.has_key('vars'):
            if self.high_contrast:
                self.color_codes['vars'] = 'white'
            else:
                self.color_codes['vars'] = 'black'

        self.mode = None
        self.profile = None
        self.outputs = None
        self.topo = None
        self.graph = None
        self.edge_style = ''

        # These variables track the number of elements we've seen so far
        # and are used to generate unique names for the nodes (see
        # self.tree and self.name_mapping)
        self.apply_counter = 1
        self.var_counter = 1

        # this is a nested dictionary of GraphNode instances as values
        # and keys (generated by us) that are the names (not labels)
        # of the nodes in the dot graph.
        self.tree = {}

        # the keys are objects (Apply nodes, variables) and the values are
        # GraphNode instances that we have assigned.
        self.name_mapping = {}

        # list of Extension inheritants
        self.extensions = []

        # Used to update the inputs that have an update function
        self.input_update = {}

    def run(self):
        """
        Generates a file from provided input.
        """
        self._collect_fct_data(self.fct)
        self.graph = pd.Dot(graph_type='digraph', rankdir="LR")
        self.ext_setup()

        for node_idx, node in enumerate(self.topo):
            #if node_idx > 1:
            #    break
            apply_node = self.process_raw_node(node_idx, node)

            for identif, var in enumerate(node.inputs):
                self.process_raw_input(var=var,
                                       parent=apply_node,
                                       identif=identif)
            for identif, var in enumerate(node.outputs):
                self.process_raw_output(var=var,
                                        parent=apply_node,
                                        identif=identif)

        self.ext_tear_down()

    def process_raw_input(self, var, parent, identif):
        """
        Inserts a raw node into the graph.

        Parameters
        ----------
        var : gof.Variable
            The node to insert.
        parent : GraphNode
            Parent Apply node.
        identif : int
            The identifier of the node in parent Apply node.
        Returns
        -------
        result : GraphNode
            Either an existing or a new node.
        """
        grnode = self.add_or_get_var(var=var, index=identif)
        grnode.kind = 'input'
        color = self.color_for_object(grnode.obj)

        edge_lbl = self.edge_label(var, parent.obj.inputs, identif)
        edge_col = self.color_codes['edge']
        op = parent.obj.op
        if hasattr(op, 'view_map'):
            if identif in reduce(list.__add__, op.view_map.values(), []):
                edge_col = self.color_codes['view']
        elif hasattr(op, 'destroy_map'):
            if identif in reduce(list.__add__, op.destroy_map.values(), []):
                edge_col = self.color_codes['destroy']

        if var.owner is None:
            color = color if color else self.color_codes['inputs']
            grnode.dotnode = self.create_dot_var(name=grnode.name,
                                                 color=color,
                                                 label=grnode.label)
            self.graph.add_edge(pd.Edge(src=grnode.name,
                                        dst=parent.name,
                                        labelaligned=True,
                                        label=edge_lbl,
                                        style=self.edge_style,
                                        color=edge_col))
        elif var.name or not self.compact:
            self.graph.add_edge(pd.Edge(src=grnode.name,
                                        dst=parent.name,
                                        labelaligned=True,
                                        label=edge_lbl,
                                        style=self.edge_style,
                                        color=edge_col))
        else:
            # no name, so we don't make a var ellipse
            src_node = self.name_mapping[var.owner]
            self.graph.add_edge(pd.Edge(src=src_node.name,
                                        dst=parent.name,
                                        labelaligned=True,
                                        label=edge_lbl,
                                        style=self.edge_style,
                                        color=edge_col))

        self.var_counter = self.var_counter + 1
        self.ext_input(grnode)
        return grnode

    def process_raw_output(self, var, parent, identif):
        """
        Inserts a raw node into the graph.

        Parameters
        ----------
        node_idx : int
            The index of the node in topology.
        var : gof.Variable
            The node to insert.

        Returns
        -------
        result : GraphNode
            Either an existing or a new node.
        """
        grnode = self.add_or_get_var(var=var, index=identif)
        grnode.kind = 'input'
        color = self.color_for_object(grnode.obj)

        edge_lbl = self.edge_label(var, parent.obj.outputs, identif)
        edge_col = self.color_codes['edge']
        b_edge = False
        b_node = False

        if not color:
            if var in self.input_update:
                color = self.color_codes['input_update']
        if var in self.outputs:
            color = color if color else self.color_codes['outputs']
            b_edge = True
            b_node = True
        elif len(var.clients) == 0:
            color = color if color else self.color_codes['noclients']
            b_edge = True
            b_node = True
        elif var.name or not self.compact:
            b_edge = True
            b_node = True
        #else:
        # don't add egde here as it is already added from the inputs.

        self.var_counter = self.var_counter + 1
        if b_edge:
            self.graph.add_edge(pd.Edge(src=parent.name,
                                        dst=grnode.name,
                                        label=edge_lbl,
                                        labelaligned=True,
                                        style=self.edge_style,
                                        color=edge_col))
        if b_node:
            grnode.dotnode = self.create_dot_var(name=grnode.name,
                                                 color=color,
                                                 label=grnode.label)
            self.ext_output(grnode)
        return grnode

    def edge_label(self, var, parent_cnt, identif):
        """
        Create a proper label for an edge.
        """
        edge_lbl = str(var.type)
        if len(parent_cnt) > 1:
            edge_lbl = str(identif) + ' ' + edge_lbl
        if len(edge_lbl) > self.max_label_size:
            edge_lbl = edge_lbl[:self.max_label_size - 3] + '...'
        return edge_lbl

    def process_raw_node(self, node_idx, node):
        """
        Inserts a raw node into the graph.

        Parameters
        ----------
        node_idx : int
            The index of the node in topology.
        node : gof.ApplyNode
            The node to insert.

        Returns
        -------
        result : GraphNode
            Either an existing or a new node.
        """
        grnode = self.add_or_get_apply(obj=node, index=node_idx)

        grnode.kind = 'apply'
        color = self.color_for_object(grnode.obj.op)
        color = color if color else self.color_codes['apply']
        grnode.dotnode = self.create_dot_apply(name=grnode.name,
                                               color=color,
                                               label=grnode.label)

        self.apply_counter = self.apply_counter + 1
        self.ext_apply(grnode)
        return grnode

    def add_or_get_var(self, var, name=None, index=-1):
        """
        High level function to add an variable node to the tree.

        Parameters
        ----------
        var : Variable
            The node to insert.
        name : str, optional
            The unique name that will be used to identify this node in our
            tree and in dot graph. If not provided unique_var_name()
            will be used to to generate it.

        Returns
        -------
        result : GraphNode
            Either an existing or a new node.
        """
        assert isinstance(var, gof.Variable)
        try:
            result = self.name_mapping[var]
            return result
        except KeyError:
            pass

        if name is None:
            name = self.unique_var_name()
        else:
            assert len(name) > 0

        result = self.add_node(name=name, obj=var, index=index)
        result.label = self.generate_var_label(var)

        return result

    def add_or_get_apply(self, obj, name=None, index=-1):
        """
        High level function to add an apply node to the tree.

        Parameters
        ----------
        obj : ApplyNode
            The node to insert.
        name : str, optional
            The unique name that will be used to identify this node in our
            tree and in dot graph. If not provided unique_apply_name()
            will be used to to generate it.
        index : int
            Index in parent.
        Returns
        -------
        result : GraphNode
            Either an existing or a new node.
        """
        assert isinstance(obj, gof.Apply)
        try:
            result = self.name_mapping[obj]
            return result
        except KeyError:
            pass

        if name is None:
            name = self.unique_apply_name()
        else:
            assert len(name) > 0

        result = self.add_node(name=name, obj=obj, index=index)
        result.label = self.generate_apply_label(obj)

        return result

    def generate_var_label(self, node):
        """
        Generates a label for a variable.

        Parameters
        ----------
        node : gof.Variable
            The node to label.

        Returns
        -------
        varstr : string
            The label to use.
        """

        if node in self.input_update:
            var_name = self.input_update[node].variable.name
            if var_name is None:
                prefix_u = 'UPDATE '
            else:
                prefix_u = '%s UPDATE ' % var_name
        else:
            prefix_u = ''
        if self.var_with_name_simple:
            tystr = ''
        else:
            tystr = '\n<%s>' % str(node.type)
        if node.name is not None:
            name = node.name
        else:
            name = '~unnamed~\n<%s>' % str(node.type)
            tystr = ''
        varstr = prefix_u + name + tystr

        if len(varstr) > self.max_label_size:
            varstr = varstr[:self.max_label_size-3] + '...'

        return varstr

    def generate_apply_label(self, node):
        """
        Generates a label for a node.

        This is a higher level method that uses self.apply_label_profile()
        and self.apply_label_mode() if appropriate.

        Parameters
        ----------
        node : gof.Apply
            The node to label.
        prefix : str
            The prefix to use in the final name.

        Returns
        -------
        result : string
            The label to use.
        """
        result = str(node.op).replace(':', '_')
        if self.mode:
            result = self.apply_label_mode(node, result)
        elif self.profile:
            result = self.apply_label_profile(node, result)
        return result

    def apply_label_profile(self, node, prefix):
        """
        Generates a label for a node that has profile information.

        # Update the inputs that have an update function
        self.input_update = {}
        Parameters
        ----------
        node : gof.Apply
            The node to label.
        prefix : str
            The prefix to use in the final name.

        Returns
        -------
        result : string
            The label to use.
        """
        time = self.profile.apply_time.get(node, 0)
        # second, %fct time in profiler
        if self.profile.fct_callcount == 0:
            pf = 0
        else:
            pf = time * 100 / self.profile.fct_call_time
        result = prefix + '   (%.3fs,%.3f%%)' % (time, pf)
        return result

    def apply_label_mode(self, node, prefix):
        """
        Generates a label for a node that has mode information.

        Parameters
        ----------
        node : gof.Apply
            The node to label.
        prefix : str
            The prefix to use in the final name.

        Returns
        -------
        result : string
            The label to use.
        """
        time = self.mode.profile_stats[self.fct].apply_time.get(node, 0)
        # second, % total time in profiler, %fct time in profiler
        if self.mode.local_time == 0:
            pt = 0
        else:
            pt = time * 100 / self.mode.local_time
        if self.mode.profile_stats[self.fct].fct_callcount == 0:
            pf = 0
        else:
            call_t = self.mode.profile_stats[self.fct].fct_call_time
            pf = time * 100 / call_t
        result = prefix + '   (%.3fs,%.3f%%,%.3f%%)' % (time, pt, pf)
        return result

    def add_node(self, name, obj, parent=None, index=-1):
        """
        Adds a node to our tree.

        The node is inserted in self.tree and in self.name_mapping.
        This is a more low level method. Use add_or_get

        Parameters
        ----------
        name : str
            The unique name that will be used to identify this node in our
            tree and in dot graph. unique_apply_name() or unique_var_name()
            can be used to to generate this.
        obj : object
            The actual object that will be inserted.
        parent : GraphNode, optional
            Parent node or None to insert it at top level.
        index : int
            Index in parent object (NOT parent argument)
        Returns
        -------
        new_node : GraphNode
            The object that was created for this node.
        """
        assert len(name) > 0
        assert not obj is None
        assert not self.name_mapping.has_key(obj)

        new_node = GraphNode(name, obj, parent, index)
        if parent is None:
            assert not self.tree.has_key(name)
            self.tree[name] = new_node
        else:
            assert isinstance(parent, GraphNode)
            assert not parent.subtree.has_key(name)
            parent.subtree[name] = new_node
        self.name_mapping[obj] = new_node
        return new_node

    def unique_apply_name(self):
        """
        Generates a unique name and increments the `apply node` counter.
        """
        result = 'apply_%d' % self.apply_counter
        self.apply_counter = self.apply_counter + 1
        return result

    def unique_var_name(self):
        """
        Generates a unique name and increments the `variable node` counter.
        """
        result = 'var_%d' % self.var_counter
        self.var_counter = self.var_counter + 1
        return result

    def _collect_fct_data(self, fct):
        """
        Colects mode, profile, outputs and topology from the provided function.
        """

        if isinstance(fct, Function):
            self.mode = fct.maker.mode
            self.profile = getattr(fct, "profile", None)
            if (not isinstance(self.mode, ProfileMode) or
                    fct not in self.mode.profile_stats):
                self.mode = None
            self.outputs = fct.maker.fgraph.outputs
            self.topo = fct.maker.fgraph.toposort()
        elif isinstance(fct, gof.FunctionGraph):
            self.outputs = fct.outputs
            self.topo = fct.toposort()
        else:
            if isinstance(fct, gof.Variable):
                fct = [fct]
            elif isinstance(fct, gof.Apply):
                fct = fct.outputs
            assert isinstance(fct, (list, tuple))
            assert all(isinstance(v, gof.Variable) for v in fct)
            fct = gof.FunctionGraph(inputs=gof.graph.inputs(fct),
                                    outputs=fct)
            self.outputs = fct.outputs
            self.topo = fct.toposort()

        # Here outputs can be the original list but, as we should not change
        # it, we must copy it.
        self.outputs = list(self.outputs)
        if isinstance(fct, Function):
            for i in reversed(fct.maker.expanded_inputs):
                if i.update is not None:
                    self.input_update[self.outputs.pop()] = i

    def path_from_applyn(self, srcnode):
        """
        Extract the trace from an Apply instance.

        Parameters
        ----------
        srcnode : gof.Apply
            The node in question.

        Returns
        -------
        result : list of strings
            The trace for when the Op was created.
        """
        result = None
        if not hasattr(srcnode.tag, 'trace'):
            if hasattr(srcnode.op, 'tag'):
                if hasattr(srcnode.op.tag, 'trace'):
                    result = self.path_from_tag(srcnode.op.tag)
            if hasattr(srcnode.op, 'backup_tag'):
                if hasattr(srcnode.op.backup_tag, 'trace'):
                    result = self.path_from_tag(srcnode.op.backup_tag)
        else:
            result = self.path_from_tag(srcnode.tag)
        return result

    def color_for_object(self, obj):
        """
        Tries to locate a clor for the class of provided object.

        Parameters
        ----------
        obj : object
            The object in question.

        Returns
        -------
        result : string
            The color to use of None if the class was not found.
        """
        result = None
        for op_name, color in self.color_codes.items():
            if op_name in obj.__class__.__name__:
                result = color
                break
        return result

    def create_dot_apply(self, name, color, label, shape='ellipse'):
        """
        Creates a dot node and inserts it in the graph.

        Parameters
        ----------
        name : str
            The object in question.

        Returns
        -------
        nw_node : pydot.Node
            Newly created node.
        """
        assert len(name) > 0
        assert len(label) > 0
        assert isinstance(name, basestring)
        assert isinstance(label, basestring)

        if color is None:
            nw_node = pd.Node(name=name,
                              label=label,
                              shape=shape)
        elif self.high_contrast:
            nw_node = pd.Node(name=name,
                              label=label,
                              style='filled',
                              fillcolor=color,
                              shape=shape)
        else:
            nw_node = pd.Node(name=name,
                              label=label,
                              color=color,
                              shape=shape)
        self.graph.add_node(nw_node)
        return nw_node

    def create_dot_var(self, name, color, label, shape='box', style=''):
        """
        Creates a dot node and inserts it in the graph.

        Parameters
        ----------
        name : str
            The object in question.
        name : str
            The object in question.
        name : str
            The object in question.
        name : str
            The object in question.

        Returns
        -------
        nw_node : pydot.Node
            Newly created node.
        """
        assert len(name) > 0
        assert len(label) > 0
        assert isinstance(name, basestring)
        assert isinstance(label, basestring)

        if self.high_contrast:
            color = color if color else 'white'
            style = style if style else 'filled'
            var_node = pd.Node(name=name,
                               label=label,
                               style=style,
                               fillcolor=color,
                               shape=shape)
        else:
            color = color if color else 'black'
            var_node = pd.Node(name=name,
                               label=label,
                               color=color,
                               style=style,
                               shape=shape)
        self.graph.add_node(var_node)
        return var_node

    def add_legend(self):
        """
        Creates a cluster to act as a legend.
        """
        sgleg = pd.Cluster(graph_name="cluster_legend",
                           label="Legend",
                           fontsize="15",
                           color="red",
                           style="filled",
                           fillcolor="lightgrey")
        sgleg_var = pd.Cluster('l_var', label="Variables", color="lightgrey")
        sgleg_op = pd.Cluster('l_op', label="Opperations", color="lightgrey")
        sgleg_edge = pd.Cluster('l_edge', label="Graph Flow", color="lightgrey")

        def add_var(ncnt, color, label):
            node = self.create_dot_var(name='leg_var_%d' % ncnt,
                                       color=self.color_codes[color],
                                       label=label,
                                       shape='box')
            if ncnt != 1:
                self.graph.add_edge(pd.Edge(src='leg_var_%d' % (ncnt-1),
                                            dst=node.get_name(),
                                            style='invis'))
            sgleg_var.add_node(node)
            return ncnt + 1
        def add_op(ncnt, color, label):
            node = self.create_dot_var(name='leg_op_%d' % ncnt,
                                       color=self.color_codes[color],
                                       label=label,
                                       shape='ellipse')
            if ncnt != 1:
                self.graph.add_edge(pd.Edge(src='leg_op_%d' % (ncnt-1),
                                            dst=node.get_name(),
                                            style='invis'))
            sgleg_op.add_node(node)
            return ncnt + 1

        def add_edge(ncnt, color, label):
            node1 = self.create_dot_var(name='leg_edge_%d' % ncnt,
                                        color=self.color_codes['noclients'],
                                        label=' ',
                                        style='invis',
                                        shape='none')
            node2 = self.create_dot_var(name='leg_edge_%d' % (ncnt+1),
                                        color=self.color_codes['noclients'],
                                        label=' ',
                                        style='invis',
                                        shape='none')
            self.graph.add_edge(pd.Edge(src=node1.get_name(),
                                        dst=node2.get_name(),
                                        labelaligned=True,
                                        label=label,
                                        constraint=False,
                                        color=self.color_codes[color]))
            if ncnt != 1:
                self.graph.add_edge(pd.Edge(src='leg_edge_%d' % (ncnt-2),
                                            dst=node1.get_name(),
                                            style='invis'))
                self.graph.add_edge(pd.Edge(src='leg_edge_%d' % (ncnt-2),
                                            dst=node2.get_name(),
                                            style='invis'))
            sgleg_edge.add_node(node1)
            sgleg_edge.add_node(node2)
            return ncnt + 2

        ncnt = 1
        ncnt = add_var(ncnt, 'inputs', 'Input Variable')
        ncnt = add_var(ncnt, 'outputs', 'Output Variable')
        ncnt = add_var(ncnt, 'input_update', 'Updated Input')
        s_lbl = 'Intermediate Variable'
        if not self.var_with_name_simple:
            s_lbl = s_lbl + '\n<Type in brackets>'
        ncnt = add_var(ncnt, 'vars', s_lbl)
        ncnt = add_var(ncnt, 'vars', '~unnamed~\nsome have no name')
        ncnt = add_var(ncnt, 'noclients', 'Variable w/o clients')

        ncnt = 1
        ncnt = add_op(ncnt, 'GpuFromHost', 'To/From Gpu')
        ncnt = add_op(ncnt, 'Scan', 'Scan')
        ncnt = add_op(ncnt, 'Shpae', 'Shape')
        ncnt = add_op(ncnt, 'IfElse', 'If - Else')
        ncnt = add_op(ncnt, 'Elemwise', 'Elemwise')
        ncnt = add_op(ncnt, 'Subtensor', 'Subtensor')
        ncnt = add_op(ncnt, 'Alloc', 'Alloc')
        ncnt = add_op(ncnt, 'apply', 'Generic Op')

        ncnt = 1
        ncnt = add_edge(ncnt, 'edge', 'Variable type')
        ncnt = add_edge(ncnt, 'view', 'View of the input')
        ncnt = add_edge(ncnt, 'destroy', 'Destroy input')

        sgleg.add_subgraph(sgleg_var)
        sgleg.add_subgraph(sgleg_op)
        sgleg.add_subgraph(sgleg_edge)
        self.graph.add_subgraph(sgleg)

    def create_subgraphs(self):
        """
        Create subgraph files for Scan ops in the graph.
        """
        scan_ops = [(idx, x) for idx, x in enumerate(self.topo)
                    if isinstance(x.op, theano.scan_module.scan_op.Scan)]
        path, fn = os.path.split(self.outfile)
        basename = '.'.join(fn.split('.')[:-1])
        # Safe way of doing things .. a file name may contain multiple .
        ext = fn[len(basename):]

        for idx, scan_op in scan_ops:
            # is there a chance that name is not defined?
            if hasattr(scan_op.op, 'name'):
                new_name = basename + '_' + scan_op.op.name + '_' + str(idx)
            else:
                new_name = basename + '_' + str(idx)
            new_name = os.path.join(path, new_name + ext)

            pydotprint(fct=scan_op.op.fn,
                       outfile=new_name,
                       compact=self.compact,
                       format=self.outfrm,
                       with_ids=self.with_ids,
                       high_contrast=self.high_contrast,
                       cond_highlight=False,
                       colorCodes=self.color_codes,
                       max_label_size=self.max_label_size,
                       scan_graphs=False,
                       var_with_name_simple=self.var_with_name_simple,
                       print_output_file=True,
                       assert_nb_all_strings=-1,
                       return_image=False)

    def create_image(self):
        """
        Creates an image file from current instance.
        """
        return self.graph.create(prog='dot', format=self.outfrm)

    def create_file(self, outfile=None, print_output_file=False):
        """
        Creates a file from current instance.

        Parameters
        ----------
        outfile : str,optional
            The path to the output file.
        """
        if outfile is None:
            outfile = os.path.join(config.compiledir,
                                   'theano.pydotprint.' +
                                   config.device + '.' + self.outfrm)
        elif not outfile.endswith('.' + self.outfrm):
            outfile += '.' + self.outfrm

        self.graph.write(outfile, prog='dot', format=self.outfrm)
        if print_output_file:
            print 'The output file is available at ', outfile

        return outfile

    def ext_setup(self):
        """
        Called once the function was parsed and before any (potential) nodes.

        It is possible that an instance may receive multiple `setup()`
        calls, each followed by a coresponding `tear_down()`.
        """
        for ext in self.extensions:
            ext.setup()

    def ext_tear_down(self):
        """
        Called after all nodes were processed.
        """
        for ext in self.extensions:
            ext.tear_down()

    def ext_apply(self, node):
        """
        An apply node was added to the graph.

        Parameters
        ----------
        node : GraphNode
            The node in question.
        """
        for ext in self.extensions:
            ext.apply_node_added(node)
            ext.node_added(node, 'apply')

    def ext_input(self, node):
        """
        An input variable was added to the graph.

        Parameters
        ----------
        node : GraphNode
            The node in question.
        """
        for ext in self.extensions:
            ext.input_node_added(node)
            ext.node_added(node, 'input')

    def ext_output(self, node):
        """
        An output variable was added to the graph.

        Parameters
        ----------
        node : GraphNode
            The node in question.
        """
        for ext in self.extensions:
            ext.output_node_added(node)
            ext.node_added(node, 'output')



class Extension(object):
    """
    Class used to extend the functionality of PyDotPrinter.

    Parameters
    ----------
    base : PyDotPrinter
        The instance where this extension was/will be inserted
    """
    def __init__(self, base):
        super(Extension, self).__init__()
        self.base = base

    def setup(self):
        """
        Called once the function was parsed and before any (potential) nodes.

        It is possible that an instance may receive multiple `setup()`
        calls, each followed by a coresponding `tear_down()`.
        """
        pass

    def tear_down(self):
        """
        Called after all nodes were processed.
        """
        pass

    def apply_node_added(self, node):
        """
        An apply node was added to the graph.

        Parameters
        ----------
        node : GraphNode
            The node in question.
        """
        pass

    def input_node_added(self, node):
        """
        An input variable was added to the graph.

        Parameters
        ----------
        node : GraphNode
            The node in question.
        """
        pass

    def output_node_added(self, node):
        """
        An output variable was added to the graph.

        Parameters
        ----------
        node : GraphNode
            The node in question.
        """
        pass

    def node_added(self, node, kind):
        """
        A variable was added to the graph.

        This is called with each *_node_added. The implementation
        may only use this function for simple processing.

        Parameters
        ----------
        node : GraphNode
            The node in question.
        kind : srt
            Either 'apply', 'input' or 'output'.
        """
        pass

class ExtClusterTrace(Extension):
    """
    Clusters the nodes based on their trace.

    Parameters
    ----------
    base : PyDotPrinter
        The instance where this extension was/will be inse
    """
    def __init__(self, base):
        super(ExtClusterTrace, self).__init__(base)

        # this is a nested dictionary of GraphNode instances as values
        # and keys (generated by us) that are the names (not labels)
        # of the nodes in the dot graph.
        self.tree = {}

        self.path_clusters = {}
        self.color_mapping = {}
        self.path_cluster_count = 0
        self.total_apply = 0
        self.total_var = 0
        self.add_count = 0
        self.uniq_node = 0
        self.uniq_var = 0

        raise NotImplementedError("ExtClusterTrace crashes dot at this time.")

    def setup(self):
        """
        Called once the function was parsed and before any (potential) nodes.

        It is possible that an instance may receive multiple `setup()`
        calls, each followed by a coresponding `tear_down()`.
        """
        pass

    def tear_down(self):
        """
        Called after all nodes were processed.
        """
        self.add_cluster_tree(None, self.path_clusters)
        print 'path_cluster_count: ', self.path_cluster_count
        print 'apply nodes: ', self.total_apply
        print 'variables: ', self.total_var
        print 'add_count: ', self.add_count

    def apply_node_added(self, node):
        """
        An apply node was added to the graph.

        Parameters
        ----------
        node : GraphNode
            The node in question.
        """
        if self.total_apply > 55:
            return
        node_path = self.path_from_applyn(node.obj)
        node_cluster = self.add_to_path_cluster(node_path)
        if node_cluster:
            node_cluster.add_node(node.dotnode)

    def input_node_added(self, node):
        """
        An input variable was added to the graph.

        Parameters
        ----------
        node : GraphNode
            The node in question.
        """
        if self.total_var  > 27:
            return
        if node.dotnode:
            var_path = self.path_from_var(node.obj.tag, False)
            var_cluster = self.add_to_path_cluster(var_path)
            if var_cluster:
                var_cluster.add_node(node.dotnode)

    def output_node_added(self, node):
        """
        An output variable was added to the graph.

        Parameters
        ----------
        node : GraphNode
            The node in question.
        """
        return
        self.input_node_added(node)

    def trim_path(self, path):
        for tpath in self.trim_paths:
            if path.startswith(tpath):
                return path[len(tpath)+1:]
        return path

    def add_to_path_cluster(self, path):

        if path is None:
            return
        self.add_count = self.add_count + 1
        batch = self.path_clusters
        cluster = None
        prev_path = None
        for pathel in path:
            if pathel == prev_path:
                continue
            prev_path = pathel
            if batch.has_key(pathel):
                batch, cluster = batch[pathel]
            else:
                if self.color_mapping.has_key(pathel):
                    color = self.color_mapping[pathel]
                else:
                    color = "%f 0.200 0.800" % random.random()
                    self.color_mapping[pathel] = color
                cluster = pd.Cluster(str(self.path_cluster_count),
                                     label=self.trim_path(pathel),
                                     color='#303030',
                                     style='filled',
                                     fillcolor=color)
                new_batch = {}
                batch[pathel] = [new_batch, cluster]
                batch = new_batch
                self.path_cluster_count = self.path_cluster_count + 1
        return cluster

    def add_cluster_tree(self, parentc, cltree, level=0):
        if cltree is None or len(cltree) == 0:
            return
        if parentc is None:
            for kcl in cltree:
                cluster = cltree[kcl][1]
                self.add_cluster_tree(cluster, cltree[kcl][0])
                self.base.graph.add_subgraph(cluster)
        else:
            for kcl in cltree:
                cluster = cltree[kcl][1]
                self.add_cluster_tree(cluster, cltree[kcl][0])
                parentc.add_subgraph(cluster)

    def path_from_applyn(self, srcnode):
        self.total_apply = self.total_apply + 1

        if not hasattr(srcnode.tag, 'trace'):
            if hasattr(srcnode.op, 'tag'):
                if hasattr(srcnode.op.tag, 'trace'):
                    return self.path_from_tag(srcnode.op.tag)
            if hasattr(srcnode.op, 'backup_tag'):
                if hasattr(srcnode.op.backup_tag, 'trace'):
                    return self.path_from_tag(srcnode.op.backup_tag)
            return None
        else:
            return self.path_from_tag(srcnode.tag)

    def path_from_var(self, srctag, is_input):
        self.total_var = self.total_var + 1
        return self.path_from_tag(srctag)

    def path_from_tag(self, srctag):
        if not hasattr(srctag, 'trace'):
            return None
        return [trelem[0] for trelem in srctag.trace]

    def get_var_name(self, value):
        astr = "var_" + str(self.uniq_var)
        self.uniq_var = self.uniq_var + 1
        return astr

    def get_node_name(self, value):
        astr = "apply_" + str(self.uniq_node)
        self.uniq_node = self.uniq_node + 1
        return astr



class ExtIfElseCluster(Extension):
    """
    Clusters an IfElse rule in three clusters.

    Parameters
    ----------
    base : PyDotPrinter
        The instance where this extension was/will be inse
    cond_highlight : gof.Apply
        The condition node
    """
    def __init__(self, base, cond_highlight):
        super(ExtIfElseCluster, self).__init__(base)
        self.cond_highlight = cond_highlight
        # attributes prepared by setup()
        self.middle = None
        self.left = None
        self.right = None
        self.c1 = None
        self.c2 = None
        self.c3 = None

    def setup(self):
        """
        Called once the function was parsed and before any (potential) nodes.

        It is possible that an instance may receive multiple `setup()`
        calls, each followed by a coresponding `tear_down()`.
        """
        self.c1 = pd.Cluster('Left')
        self.c2 = pd.Cluster('Right')
        self.c3 = pd.Cluster('Middle')
        cond = None
        for node in self.base.topo:
            if (node.op.__class__.__name__ == 'IfElse' and
                    node.op.name == self.cond_highlight):
                cond = node
        if cond is None:
            _logger.warn("pydotprint: cond_highlight is set but there is no"
                         " IfElse node in the graph")
            return

        def recursive_pass(x, ls):
            if not x.owner:
                return ls
            else:
                ls += [x.owner]
                for inp in x.inputs:
                    ls += recursive_pass(inp, ls)
                return ls

        left = set(recursive_pass(cond.inputs[1], []))
        right = set(recursive_pass(cond.inputs[2], []))
        middle = left.intersection(right)
        left = left.difference(middle)
        right = right.difference(middle)
        self.middle = list(middle)
        self.left = list(left)
        self.right = list(right)

    def tear_down(self):
        """
        Called after all nodes were processed.
        """
        self.base.graph.add_subgraph(self.c1)
        self.base.graph.add_subgraph(self.c2)
        self.base.graph.add_subgraph(self.c3)

        self.middle = None
        self.left = None
        self.right = None
        self.c1 = None
        self.c2 = None
        self.c3 = None

    def apply_node_added(self, node):
        """
        An apply node was added to the graph.

        Parameters
        ----------
        node : GraphNode
            The node in question.
        """
        if node.obj in self.middle:
            self.c3.add_node(node.dotnode)
        elif node.obj in self.left:
            self.c1.add_node(node.dotnode)
        elif node.obj in self.right:
            self.c2.add_node(node.dotnode)

def pydotprint(fct,
               outfile=None,
               compact=True,
               format='png',
               with_ids=False,
               high_contrast=True,
               cond_highlight=None,
               colorCodes=None,
               max_label_size=70,
               scan_graphs=False,
               var_with_name_simple=False,
               legend=False,
               cluster_trace=False,
               print_output_file=True,
               assert_nb_all_strings=-1,
               return_image=False):
    """Print to a file the graph of a compiled theano function's ops. Supports
    all pydot output formats, including png and svg.

    :param fct: a compiled Theano function, a Variable, an Apply or
                a list of Variable.
    :param outfile: the output file where to put the graph.
    :param compact: if True, will remove intermediate var that don't have name.
    :param format: the file format of the output.
    :param with_ids: Print the toposort index of the node in the node name.
                     and an index number in the variable ellipse.
    :param high_contrast: if true, the color that describes the respective
            node is filled with its corresponding color, instead of coloring
            the border
    :param color_codes: dictionary with names of ops (Ex. Elemwise, DimShuffle)
            as keys and colors as values
    :param cond_highlight: Highlights a lazy if by sorrounding each of the 3
                possible categories of ops with a border. The categories
                are: ops that are on the left branch, ops that are on the
                right branch, ops that are on both branches
                As an alternative you can provide the node that represents
                the lazy if
    :param scan_graphs: if true it will plot the inner graph of each scan op
                in files with the same name as the name given for the main
                file to which the name of the scan op is concatenated and
                the index in the toposort of the scan.
                This index can be printed with the option with_ids.
    :param var_with_name_simple: If true and a variable have a name,
                we will print only the variable name.
                Otherwise, we concatenate the type to the var name.
    :param legend: If true a legend is added.
    :param cluster_trace: Cluster based on backtrace at creation time.
    :param assert_nb_all_strings: Used for tests. If non-negative, assert that
                the number of unique string nodes in the dot graph is equal to
                this number. This is used in tests to verify that dot won't
                merge Theano nodes.
    :param return_image: If True, it will create the image and return it.
        Useful to display the image in ipython notebook.

        .. code-block:: python

            import theano
            v = theano.tensor.vector()
            from IPython.display import SVG
            SVG(theano.printing.pydotprint(v*2, return_image=True,
                                           format='svg'))

    In the graph, ellipses are Apply Nodes (the execution of an op)
    and boxes are variables.  If variables have names they are used as
    text (if multiple vars have the same name, they will be merged in
    the graph).  Otherwise, if the variable is constant, we print its
    value and finally we print the type + a unique number to prevent
    multiple vars from being merged.  We print the op of the apply in
    the Apply box with a number that represents the toposort order of
    application of those Apply.  If an Apply has more than 1 input, we
    label each edge between an input and the Apply node with the
    input's index.

    Green boxes are inputs variables to the graph,
    blue boxes are outputs variables of the graph,
    grey boxes are variables that are not outputs and are not used,
    red ellipses are transfers from/to the gpu (ops with names GpuFromHost,
    HostFromGpu).

    For edges, they are black by default. If a node returns a view
    of an input, we put the corresponding input edge in blue. If it
    returns a destroyed input, we put the corresponding edge in red.

    """
    pr = PyDotPrinter(fct=fct,
                      compact=compact,
                      outfrm=format,
                      with_ids=with_ids,
                      high_contrast=high_contrast,
                      color_codes=colorCodes,
                      max_label_size=max_label_size,
                      var_with_name_simple=var_with_name_simple)

    if cond_highlight:
        pr.extensions.append(ExtIfElseCluster(pr, cond_highlight))
    if cluster_trace:
        pr.extensions.append(ExtClusterTrace(pr))
    pr.run()

    if scan_graphs:
        pr.create_subgraphs()

    if legend:
        pr.add_legend()

    if assert_nb_all_strings != -1:
        assert len(pr.name_mapping) == assert_nb_all_strings, \
             len(pr.name_mapping)

    if return_image:
        return pr.create_image()
    else:
        return pr.create_file(outfile, print_output_file)
